## Выбор софта

Зачем вообще нужен syslog-сервер, когда есть elastic beats, logstash, systemd-journal-remote и ещё много новых блестящих технологий?

- Это стандарт для ведения логов в POSIX-совместимых системах.

Некоторый софт, например haproxy, использует только его. То есть совсем избавится от syslog вам всё равно не удастся
- Его использует сетевое железо
- Сложнее в настройке, но богаче по возможностям, чем альтернативные решения.

Например, Elastic Filebeat до сих пор не умеет inotify.

- Нетребователен к памяти
- Позволяет фильтровать сообщение перед сохранением/пересылкой.

Странная задача, но иногда требуется. Например, [PCI DSS](https://ru.wikipedia.org/wiki/PCI_DSS) в разделе 3.4 требует маскировать или шифровать номера карт, если они сохраняются на диск. Тонкость в том, что если кто-то ввёл номер карты в строку поиска или в форму обратной связи, то как только вы сохранили запрос в лог, вы нарушаете стандарт. Наблюдение: пользователи пытаются ввести номер карты в любое поле ввода на странице, и норовят сообщить его саппорту вместе с CVV и PIN.

<cut />

## Формат сообщений и legacy

TLDR: всё плохо.

syslog появился в 80-х, и быстро стал стандартом логирования для Unix-like систем и сетевого оборудования. Стандарта не было, все писали по принципу совместимости с существующим софтом. В 2001 IETF описал текущее положение вещей в RFC 3164(статус "informational"). Т. к. реализации очень отличаются, то в частности в этом документе сказано "содержание любого IP пакета отправленного на UDP порт 514 должно рассматриваться как сообщение syslog". Потом попробовали стандартизировать формат в RFC 3195, но документ получился неудачным, для него в данный момент нету ни одной живой реализации. В 2009 приняли RFC 5424, определяющий структурированные сообщения, но этим редко кто пользуется.

[Вот тут](http://www.rsyslog.com/doc/syslog_parsing.html) можно прочитать, что обо всём этом думает автор rsyslog Рейнер Герхард(Rainer Gerhards). Фактически, по-прежнему все реализуют syslog как попало, и задача интерпретировать всё это ложиться на syslog-сервер. Например, в rsyslog включен [специальный модуль](http://www.rsyslog.com/doc/v8-stable/configuration/modules/pmciscoios.html) для разбора формата, используемого CISCO IOS, ну и для самых плохих случаев начиная с пятой версии можно определять собственные парсеры.

Сообщения syslog при передаче по сети выглядят примерно так:

```
<PRI> TIMESTAMP HOST TAG MSG
```

- PRI - Priority. Вычисляется как `facility*8 + severity`. Facilicy(категория) принимает значения от 0 до 23, им соответствуют различные категории системных служб: 0 - kernel, 2 - mail, 7 - news. [Полный список](https://en.wikipedia.org/wiki/Syslog#Facility). Последние 8 - от local0 до local7 - определены для служб, не попадающих в предопределённые катигории. Severity(важность) принимает значения от 0(emergency, самая высокая) до 7(debug, самая низкая). [Полный список](https://en.wikipedia.org/wiki/Syslog#Severity_level).
- TIMESTAMP - время, обычно в формате "Feb  6 18:45:01". Согласно RFC 3164, может записываться в формате времени ISO 8601: "2017-02-06T18:45:01.519832+03:00" с большей точностью и с учётом используемой временной зоны.
- HOST - имя хоста, сгенерировавшего сообщение
- TAG - содержит имя программы, сгенерировавшей сообщение.  Не более 32 алфавитно-цифровых символов, хотя по факту многие реализации позволяют больше. Любой не-алфавитноцифровой символ заканчивает TAG и начинает MSG, обычно используется двоеточие. Иногда в квадратных скобках содержит номер сгенерироваашего сообщение процесса. Т. к. [] - не алфавитно-цифровые символы, то номер процесса вместе с ними должен считаться частью сообщения. Но обычно все реализации считают это частью тега, считая сообщением всё, начиная с ": ".
- MSG - сообщение. Из-за неопределённости с тем, где же кончается тег и начинается сообщение, в начало может приклеивается пробел. Не может содержать символов перевода строки. Способы всё же пересылать multi-line сообщение:
    - экранирование. Либо читаем на стороне приёмника текст с `#012` или `\n`, либо раскодируем обратно на стороне приёмника, но тогда могут искажаться сообщения, содержащие такие сочетания символов.
    - использование octet-counted TCP Framing, как определено в RFC 5425 для TLS-enabled syslog. Нестандарт, только некоторые реализации.

Если сообщения пересылаются между хостами, использующими rsyslog, можно вместо plain TCP sysog использовать [RELP](http://www.rsyslog.com/doc/relp.html) - Reliable Event Logging Protocol. Был создан для rsyslog, сейчас поддерживается и некоторыми другими системами. В частности, его понимают Logstash и Graylog. Для транспорта использует TCP. Может опционально шифровать сообщения с помощью TLS. Надёжнее plain TCP, т. к. имеет подтверждение доставки сообщений. Решает проблему с multi-line сообщениями.

## Конфигурация rsyslog

В отличии от второй распространённой альтернативы, syslog-ng, rsyslog совместим с конфигами исторического syslogd:

```
auth,authpriv.*            /var/log/auth.log
*.*;auth,authpriv.none     /var/log/syslog

*.*       @192.168.1.1
```

Т. к. возможности rsyslog гораздо больше, чем у его предшественника, формат конфигов был расширен директивами, начинающимися со знака `$`:

```
$ActionFileDefaultTemplate RSYSLOG_TraditionalFileFormat
$WorkDirectory /var/spool/rsyslog
$IncludeConfig /etc/rsyslog.d/*.conf
```

Начиная с шестой версии, появился C-подобный формат RainerScript, позволяющий задавать сложные правила обработки сообщений.

Т. к. всё это делалось постепенно и с учётом совместимости со старыми конфигами, то в итоге получилась пара неприятных моментов:
- некоторые плагины(я пока с такими не сталкивался) могут не поддерживать новый RainerScript стиль настроек, им по-прежнему нужны старые директивы
- настройка через старые директивы не всегда работает как ожидается для нового формата:
    - если модуль `omfile` вызывается с помощью старого формата: `auth,authpriv.*  /var/log/auth.log`, то владелец и разрешения получившегося файла регулируются старыми директивами `$FileOwner`, `$FileGroup`, `$FileCreateMode`. А вот если он вызывается с помощью `action(type="omfile" ...)`, то эти директивы игнорируются, и надо настраивать параметы action или задавать при загрузке модуля
    - Директивы вида `$ActionQueueXXX` настраивают только очередь, которая будет использована в первом action после них, потом хзначения сбрасываются.

Чтобы не спотыкаться об эти тонкости(да, в документации они описаны, но кто же её целиком читает?), стоит следовать простым правилам:
- для маленьких простых конфигов использовать старый формат:  `:programname, startswith, "haproxy"  /var/log/haproxy.log`
- для сложной обработки сообщений всегда использовать RainerScript, не трогая legacy директивы вида `$DoSomething`

---

 - почему rsyslog
     - используется некоторым софтом, то есть всё равно будет на сервере
     - используется сетевыми железками
     - гибче filebeat, умеет inotify
     - фильтрация сообщений, например для PCI DSS(requirement 3.4): http://www.rsyslog.com/masking-data-in-logs-and-rsyslog/
 - формат syslog-сообщений: http://www.rsyslog.com/doc/syslog_parsing.html
     - RFCs
     - real life
     - legacy: multi-line messages, пробел в начале сообщения
     - как бороться, RELP
 - конфиги: старый и новый формат
     - старый - совместим с историческим syslogd
     - новый - с-подобный, гораздо более мощный
     - из-за необходимости поддерживать статый и новый синтаксис, директивы нового и старого формата не всегда логично сочетаются:
         - пример с omfile
         - пример с конфигурацией queue для action
     - лучше всюду, кроме небольших файлов для конкретного приложения, использовать новый
 - message flow: inputs, rulesets(default), filter+actions
 - клиент: посылаем файлы, сохраняя имя лог-файла в теге
     - шаблоны
     - multi-line файлы
     - wildcards, с сохранением имени
 - сервер: получаем файлы, раскладываем по папками, берём имя файла из тега
     - отрезаем пробел для чистых сообщений
     - производительность: буффер, flush и прочее
 - надёжная доставка сообщений на недоступный сервер. очереди: in-memory, disk-assisted in-memory
 - отказоустойчивость: использовать второй сервер при недоступности первого: http://www.rsyslog.com/doc/v8-stable/tutorials/failover_syslog_server.html action.execOnlyWhenPreviousIsSuspended

+ интеграция с systemd

ссылки:
  - rsyslog docs
  - github репо с файлами, можно с ролью ansible
